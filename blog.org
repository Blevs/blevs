#+hugo_base_dir: .
#+hugo_auto_set_lastmod: t

* Blog
  :PROPERTIES:
  :export_hugo_section: blog
  :header-args: :exports both :results code :eval never-export
  :END:
** DONE Clojure Crash Course for JavaScript Developers :wfc:
   CLOSED: [2019-04-15 Mon 02:03]
   :PROPERTIES:
   :export_file_name: clojure-crash-course
   :header-args:js: :session *Javascript REPL*
   :END:
   #+begin_src elisp :exports none
     (defun org-babel-execute:clojure (body params)
       "Execute a block of Clojure code with Babel.
     The underlying process performed by the code block can be output
     using the :show-process parameter."
       (let* ((expanded (org-babel-expand-body:clojure body params))
              (response (list 'dict))
              result)
         (cl-case org-babel-clojure-backend
           (cider
            (require 'cider)
            (let ((result-params (cdr (assq :result-params params)))
                  (show (cdr (assq :show-process params))))
              (if (member show '(nil "no"))
                  ;; Run code without showing the process.
                  (progn
                    (setq response
                          (let ((nrepl-sync-request-timeout
                                 org-babel-clojure-sync-nrepl-timeout))
                            (nrepl-sync-request:eval expanded
                                                     (cider-current-connection))))
                    (setq result
                          (concat
                           (nrepl-dict-get response
                                           (if (or (member "output" result-params)
                                                   (member "pp" result-params))
                                               "out"
                                             "out"))
                           (nrepl-dict-get response "ex")
                           (nrepl-dict-get response "root-ex")
                           (nrepl-dict-get response "err"))))
                ;; Show the process in an output buffer/window.
                (let ((process-buffer (switch-to-buffer-other-window
                                       "*Clojure Show Process Sub Buffer*"))
                      status)
                  ;; Run the Clojure code in nREPL.
                  (nrepl-request:eval
                   expanded
                   (lambda (resp)
                     (when (member "out" resp)
                       ;; Print the output of the nREPL in the output buffer.
                       (princ (nrepl-dict-get resp "out") process-buffer))
                     (when (member "ex" resp)
                       ;; In case there is an exception, then add it to the
                       ;; output buffer as well.
                       (princ (nrepl-dict-get resp "ex") process-buffer)
                       (princ (nrepl-dict-get resp "root-ex") process-buffer))
                     (when (member "err" resp)
                       ;; In case there is an error, then add it to the
                       ;; output buffer as well.
                       (princ (nrepl-dict-get resp "err") process-buffer))
                     (nrepl--merge response resp)
                     ;; Update the status of the nREPL output session.
                     (setq status (nrepl-dict-get response "status")))
                   (cider-current-connection))

                  ;; Wait until the nREPL code finished to be processed.
                  (while (not (member "done" status))
                    (nrepl-dict-put response "status" (remove "need-input" status))
                    (accept-process-output nil 0.01)
                    (redisplay))

                  ;; Delete the show buffer & window when the processing is
                  ;; finalized.
                  (mapc #'delete-window
                        (get-buffer-window-list process-buffer nil t))
                  (kill-buffer process-buffer)

                  ;; Put the output or the value in the result section of
                  ;; the code block.
                  (setq result
                        (progn
                          (message response)
                          (message (nrepl-dict-get response "output"))
                          (concat
                           (nrepl-dict-get response
                                           (if (or (member "output" result-params)
                                                   (member "pp" result-params))
                                               "out"
                                             "out" ;; "value"
                                             ))
                           (nrepl-dict-get response "ex")
                           (nrepl-dict-get response "root-ex")
                           (nrepl-dict-get response "err"))))))))
           (slime
            (require 'slime)
            (with-temp-buffer
              (insert expanded)
              (setq result
                    (slime-eval
                     `(swank:eval-and-grab-output
                       ,(buffer-substring-no-properties (point-min) (point-max)))
                     (cdr (assq :package params)))))))
         (org-babel-result-cond (cdr (assq :result-params params))
           result
           (condition-case nil (org-babel-script-escape result)
             (error result)))))

     (defun org-babel-expand-body:clojure (body params)
       "Expand BODY according to PARAMS, return the expanded body."
       (let* ((vars (org-babel--get-vars params))
              (ns (or (cdr (assq :ns params))
                      (org-babel-clojure-cider-current-ns)))
              (result-params (cdr (assq :result-params params)))
              (print-level nil)
              (print-length nil)
              (body
               (org-trim
                (format "(ns %s)\n%s"
                        ;; Source block specified namespace :ns.
                        ns
                        ;; Variables binding.
                        (if (null vars) (org-trim body)
                          (format "(let [%s]\n%s)"
                                  (mapconcat
                                   (lambda (var)
                                     (format "%S (quote %S)" (car var) (cdr var)))
                                   vars
                                   "\n      ")
                                  body))))))
         (if (or (member "code" result-params)
                 (member "pp" result-params)
                 (member "html" result-params))
             (format "(clojure.pprint/pprint (do %s))" body)
           body)))
   #+end_src

   #+begin_description
   A quick trip through the world of Clojure while we prepare to implement the
   Wave Function Collapse algorithm and build a frontend with ClojureScript.
   #+end_description
   
   Welcome to the first post in my series detailing an implementation of
   [[https://github.com/mxgmn/WaveFunctionCollapse][Wave Function Collapse]].

   Before we start writing any code, we must talk about the programming language
   we will be using --- Clojure. I assume most people following along are not
   familiar with it, so I will teach you enough to read and follow along with
   later articles.

   Many of you may only have experience with a single programming language, and
   the idea of learning another may seem daunting. Don't worry. Learning your
   second language is much easier than the first, even though Clojure may seem
   alien.
    
   In fact, many of the concepts integral to Clojure have made their way into
   JavaScript. Things like anonymous functions, map/filter/reduce and
   immutability will be familiar to you.
    
   If you would like to follow along, both [[https://repl.it/languages/clojure][repl.it]] and [[https://clojurescript.io/][clojurescript.io]] have
   repls to get you started.

*** Basic Syntax
    In JavaScript, we invoke functions the way we expect from math class:

    #+begin_src js
      function inc(x) {
          return x + 1;
      }

      inc(1);
    #+end_src

    #+RESULTS:
    #+begin_src js
    2
    #+end_src

    Let's do the same thing in Clojure

    #+begin_src clojure
      (inc 1)
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    2
    #+end_src
     
    The parenthesis go on the outside. In Clojure, instead of invoking functions
    with ~f(x)~, we do ~(f x)~. While initially confusing, it offers distinct
    advantages. One is that our code is a list. This makes it data. We can edit,
    process and modify our code using the same tools we use to work with data.
    We won't get into that here, but it is very cool.

    Second, more practically, is that it is almost all of the syntax you need to
    know. With the exception of data literals (like vectors), and some common
    macros, that is pretty much it.
     
    That includes math:

    In JavaScript
    #+begin_src js
    1 + 1
    #+end_src

    #+RESULTS:
    #+begin_src js
    2
    #+end_src
     
    In Clojure
    #+begin_src clojure
    (+ 1 1)
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    2
    #+end_src

    Notice how there are no commas between arguments. In Clojure, we use
    whitespace to separate arguments. 
     
    It is weird, right? But this lets us do things like this:

    #+begin_src clojure
    (+ 1 2 3 4 5 6)
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    21
    #+end_src

    That discomfort you may feel reading it compared to JavaScript goes away
    quickly, especially why you realize you don't have to constantly switch
    between normal function, infix operators (like ~+~), and member functions.
     
*** Functions
    In JavaScript, we define functions like so

    #+begin_src js
      function add(x, y) {
          return x + y
      }

      add(1, 2);
    #+end_src

    #+RESULTS:
    #+begin_src js
    3
    #+end_src
     
    In Clojure
    #+begin_src clojure
      (defn add [x y]
        (+ x y))

      (add 1 2)
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    3
    #+end_src
     
    Here is the basic syntax:

    #+begin_src clojure
      (defn function-name [argument1 argument2 ...]
        (body))
    #+end_src
     
    We use a macro called ~defun~ and specify a function name. Note that we can,
    and prefer, to use hyphenated (or kebabed) names for our functions. We get
    to do this because minus, ~-,~ is a function in Clojure, not a special symbol
    that must be reserved.
     
    Then, arguments are specified using a vector. Note the lack of commas.

    Finally, the function body is defined. There is no explicit ~return~
    statement because the body's value is automatically returned.

**** Anonymous Functions
     In JavaScript, we have two syntaxes: the function operator and the arrow function.
     #+begin_src js
       function(x) {
           return x + 1;
       }

       (x) => {
           return x + 1;
       }
     #+end_src
     
     In Clojure we also have two syntaxes: the function expression and the
     reader macro.
     #+begin_src clojure
       (fn [x]
         (+ x 1))

       #(+ % 1)
     #+end_src
     
     The first should be familiar and reasonable. Instead of using ~defn~, we
     write ~fn~ with no function name.

     The second is more cryptic. The reader macro is transformed by the Clojure
     parser and into the first form. It is indicated by a hashed parenthesis
     ~#()~. Inside, the ~%~ is evaluated to the first argument. We can use multiple
     arguments by adding an integer.

     #+begin_src clojure
       ;; The same as the add function
       #(+ %1 %2)
       (#(+ %1 %2) 6 8)
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     14
     #+end_src

*** Special Forms and Flow Control
    What if we want to do multiple things inside of our function body? There is
    always the ~do~ macro. This gives us an environment similar to JavaScript,
    where each line is executed independently. The value of the last expression
    executed is returned.
     
    #+begin_src clojure
      (do
        (println "Hello, World!") 
        (println 2)
        (+ 1 2))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    Hello, World!
    2
    3
    #+end_src
     
    As you can see, ~println~ is our equivalent to ~console.log~.
     
    Conditional logic is also important. In Clojure, ~if~ is an expression. It
    evaluates a statement, and then if it is true or false it executes the
    appropriate branch and returns its value.

    #+begin_src clojure
      (if true
        "yes" ;; true branch
        "no") ;; false branch
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    "yes"
    #+end_src
     
    We can use this returned value inside of other expressions

    #+begin_src clojure
      (+ 2 (if false 3 4))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    6
    #+end_src
     
    This is very similar to the ternary operator in JavaScript
    #+begin_src js
      2 + (false ? 3 : 4)
    #+end_src

    #+RESULTS:
    #+begin_src js
    6
    #+end_src
     
    Same effect, but look at how much simpler the Clojure syntax is.
     
    If you want to chain together ~if~'s and ~else~'s like in JavaScript, use [[https://clojuredocs.org/clojure.core/cond][cond]]
    instead.
     
    We also have access to our same toolkit of logical operators, but in
    Clojure they are functions instead of symbols.
     
    #+begin_src clojure
      (println (and true false)
               (or true false)
               (not true)
               (= 1 2)
               (= 1 1))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
      false 
      true
      false
      false
      true
    #+end_src
     
    You may be weirded out to see the equals sign used to test equality instead
    of assigning values. 

*** Variables
    In Clojure, we handle variables a bit differently. We tend to work with our
    data by passing it from one function to the next, instead of storing it in
    a variable and mutating it.

    However, we still want to be able to associate constant values with names,
    and to use the results of a computation in multiple places.

    In the tradition we are more familiar with, Clojure has the ~def~ macro.
    #+begin_src clojure
      (def a 1)
      (println a)
      (println (+ a 2))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1
    3
    #+end_src
     
    It defines a variable to a name. It is roughly equivalent to ~const~ in the
    global scope in JavaScript. We *do not* use ~def~ inside functions to make
    local variables.
     
    Instead, the ~let~ macro is used. 
    #+begin_src clojure
      (let [a 1
            b (+ a 2)]
        (+ a b))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    4
    #+end_src
     
    Here is the basic syntax:
    #+begin_src clojure
      (let [variable1 expression1
            variable2 expression2
            ...]
        (body))
    #+end_src
     
    It takes a vector of variable names and expressions. The expressions are
    evaluated and the variables are bound to their value inside of the ~let~'s
    scope. We can reference earlier variables within the expressions for later
    variables, as well as in the body.
     
    Again, they are constant and we do not mutate their values.
     
*** Data Structures
**** Numbers
     Like JavaScript we have integer and decimal (floating point) numbers. We
     also have fractional numbers.
      
     Math is straightforward, with the expected symbols defined as function.
     #+begin_src clojure
       1
       2.5
       (+ 3 4.6)  ; -> 7.6
       (/ 2 4)    ; -> 1/2
       (quot 2 4) ; 0
       (mod 2 4)  ; 2
       (2 / 4.0)  ; -> 0.5
       (inc 2)    ; -> 3
       (dec 3)    ; -> 2
     #+end_src

**** Strings
     Strings are also much as we expect, but unlike JavaScript they are always
     enclosed by double quotes, or created with the ~str~ function.
      
     #+begin_src clojure
       "I'm a string"
       (str "test" "other")
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     "testother"
     #+end_src
      
     Also unlike JavaScript, things like addition are not overloaded to handle
     strings.

     #+begin_src clojure
       (+ "1" "b")
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     class java.lang.ClassCastExceptionclass java.lang.ClassCastExceptionExecution error (ClassCastException) at user/eval7088 (REPL:2).
     java.lang.String cannot be cast to java.lang.Number
     #+end_src
      
     Instead, functions to work with strings are found in the ~clojure.string~
     namespace. A further discussion of namespaces is needed, but for now we
     access their functions and variables by stating a namespace followed by a
     slash and the name of what we want to access.
      
     #+begin_src clojure
       (println
        (clojure.string/trim "     trim me    ")
        (clojure.string/lower-case "ABC")
        (clojure.string/reverse "olleh")
        (clojure.string/join ", " ["a" "b" "c"]))
     #+end_src

     #+RESULTS:
     #+begin_src clojure
       "trim me"
       "abc"
       "hello"
       "a, b, c"
     #+end_src

**** Keywords
     #+begin_src clojure
       :a
       :i-am-a-keyword
       (keyword "test") ; :test
     #+end_src

     Keywords are new. They are identifiers and you can think of them as fast,
     constant strings. Keywords are commonly used as /keys/ in /maps/. They're
     great and you will see why later.

**** Vectors
     We have already seen vectors in a few places, such as defining function
     arguments. Like arrays in JavaScript, they are enclosed by square brackets.
     They do not need commas by default, but they can be used.

     #+begin_src clojure
       [1 2 3]
       ["a", 4, (fn [x] (+ x 2))]
       (vector 5 6 7)
     #+end_src
      
     There are a host of functions for working with them. Here is a sample:
     #+begin_src clojure
       ;; index access
       (nth [1 2 3] 0)   ; 1
       (get [1 2 3] 0)   ; 1
       ;; conventiently get the first few elements
       (first [1 2 3])   ; 1
       (second [1 2 3])  ; 2
       (rest [1 2 3])    ; [2 3]
       ;; add an element to the end
       (conj [1 2 3] 4)
       ;; remove an element from the end
       (pop [1 2 3])     ; [1 2]
       ;; get last element
       (peek [1 2 3])    ; 3
       ;; replace element at index
       (assoc ["a" "c" "c"] 1 "b") ; ["a" "b" "c"]
       ;; create a vector
       (vector 1 2 3)    ; [1 2 3]
     #+end_src
      
     Note that all of these operations are *immutable*. For example:
     #+begin_src clojure
       (def test-vector [1 2 3])
       (println (conj test-vector 4))
       (println test-vector)
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     [1 2 3 4]
     [1 2 3]
     #+end_src
      
     Modifying a vector, or any of our basic data structures, creates a new
     copy and does not change the old value or any variables associated with
     it. Your first thought might be that it sounds slow, wasteful or
     inconvenient.

     Immutable data structures are fast and wonderful. They are fast because
     they are implemented using persistent data structures, which is to say
     instead of creating an entirely new vector with every operation , Clojure
     creates a vector that overlaps with the original and only stores the newly
     created or modified elements.

     While that does introduce some overhead it makes data incredibly
     convenient to reason about. We never have to worry about a function
     changing data. We get what is returned. Nothing more, nothing less. If you
     have worked with modern JavaScript frameworks, you may realize how annoying
     unexpected mutation can be and how frequently you visit [[https://doesitmutate.xyz][doesitmutate.xyz]].
      
**** Lists
     We also have lists. They are like our code, but with a ~'~ in front
     indicating it is a literal value.
      
     #+begin_src clojure
       '(1 2 3)
       (list 1 2 3) ; '(1 2 3)
     #+end_src
     
     In fact, it is our code
     #+begin_src clojure
       (eval '(inc 1))
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     2
     #+end_src

     They are similar to vectors, but each element is internally linked to the
     next. We have to traverse the list to access elements, but it is very fast
     to add items to the front. They are also /lazy/, which we will explain
     later.

     #+begin_src clojure
       ;; index access (works, but is slow)
       (nth '(1 2 3) 2)   ; 3
       ;; get doesn't work, because it is technically a key lookup
       (get '(1 2 3) 0)   ; nil
       ;; conventiently get the first few elements
       (first '(1 2 3))   ; 1
       (second '(1 2 3))  ; 2
       (rest '(1 2 3))    ; '(2 3)
       ;; add an element to the front
       (conj '(2 3 4) 1)  ; '(1 2 3 4)
       (cons 1 '(2 3 4))  ; '(1 2 3 4)
       ;; remove an element from the front
       (pop '(1 2 3))     ; '(2 3)
       ;; get last element
       (last '(1 2 3))    ; 3
     #+end_src
      
     If you are paying close attention you may have noticed something strange.
     ~conj~ and ~pop~ add and removes items from the /beginning/ of a list, but add
     and remove items from the /end/ of a vector.
      
     This is because it is efficient to add and remove items from the beginning
     of a list, and efficient to add and remove items at the end of a vector.
      
     The efficient option is performed by default, and adding items to the end
     of a list or the beginning of a vector is made deliberately difficult
     because it means you should either pick another data structure or be aware
     of the detriment to performance.

**** Maps
     Maps are like Objects, but they lack prototype functions. Unlike
     JavaScript, we can use any data type as the key. We can also use commas if
     we like to make them easier to read. 
      
     #+begin_src clojure 
       {:a 1 :b 2}
       {:a 1, :b 2}
       {1 2, 3 4}
       (hash-map :a 1 :b 2)
     #+end_src
      
     We commonly use keywords as keys in maps because the are fast, and we can
     also use them as functions to access their value
      
     #+begin_src clojure
       (:b {:a 1 :b 2})
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     2
     #+end_src
      
     You can think of this as a Clojure equivalent to ~Object.property~ syntax in
     JavaScript. Note that it does not work with other types:
     #+begin_src clojure
       ("b" {"a" 1 "b" 2})
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     class java.lang.ClassCastExceptionclass java.lang.ClassCastExceptionExecution error (ClassCastException) at user/eval7164 (REPL:2).
     java.lang.String cannot be cast to clojure.lang.IFn
     #+end_src

     The functions that operate on them have significant overlap with vectors
     as maps and vectors are implemented very similarly.
      
     #+begin_src clojure
       ;; get value
       (get {:a 1 :b 2} :a)             ; 1
       (:a {:a 1 :b 2})                 ; 1
       (get {"a" 1 "b" 2} "b")          ; 2
       ;; add or change a value for a given key
       (assoc {:a 1 :b 2} :c 3)         ; {:a 1 :b 2 :c 3}
       (assoc {:a 1 :b 2} :b 3)         ; {:a 1 :b 3}
       ;; add a pair
       (conj {:a 1 :b 2} [:c 3])        ; {:a 1 :b 2 :c 3}
       ;; merge maps
       (merge {:a 1 :b 2} {:b 3 :c 4})  ; {:a 1 :b 3 :c 4}
       ;; remove a key and value
       (dissoc {:a 1 :b 2} :b)          ; {:a 1}
       ;; get a subset of the map
       (select-keys {:a 1 :b 2 :c 3} [:a :b]) ; {:a 1 :b 2}
     #+end_src

**** More
     Clojure has more built in data structures, like sets, sorted-sets,
     sorted-maps and a few more.
      
     Clojure also has a very *large standard library* full of incredibly useful,
     specific and well named functions for working with and creating data. You
     can find them all on [[https://clojuredocs.org/core-library][ClojureDocs]]. We will use some of them in the
     concluding example problems.

*** Sequence functions and Laziness
    One of the best things to happen to JavaScript was the addition of the
    sequence functions ~map~, ~filter~ and ~reduce~. Map applies an operation each
    element of a sequence and returns the resulting sequence. Filter performs a
    test on each element and keeps those that pass. Reduce takes an accumulator
    value and folds each element into that accumulator.

    In Clojure, they all have the same syntax:
    #+begin_src clojure
      (map function collection)
      (filter function collection)
      (reduce function collection) ;; function is of two variables
    #+end_src
     
    In JavaScript, if we wanted to double each number of an array:
    #+begin_src js 
      [1, 2, 3].map(x => x * 2)
    #+end_src

    #+RESULTS:
    #+begin_src js
    [2,4,6]
    #+end_src
     
    In Clojure the following are equivalent:
    #+begin_src clojure
      (map (fn [x] (* x 2)) [1 2 3])
      (map #(* % 2) [1 2 3])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    (2 4 6)
    #+end_src
     
    We can use a reducer to sum an array. In JavaScript:
    #+begin_src js
      [1, 2, 3].reduce((acc, x) => acc + x)
    #+end_src

    #+RESULTS:
    #+begin_src js
    6
    #+end_src
     
    In Clojure:
    #+begin_src clojure
      (reduce (fn [acc x] (+ acc x)) [1 2 3])
      (reduce #(+ %1 %2) [1 2 3])
      (reduce + [1 2 3])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    6
    #+end_src
     
    You can also see why it is an advantage to have ~+~ be a function.
     
    We could use a filter to remove odd elements. In JavaScript:
    #+begin_src js
      [1, 2, 3, 4].filter(x => x % 2 === 0)
    #+end_src

    #+RESULTS:
    #+begin_src js
    [2,4]
    #+end_src
     
    In Clojure:
    #+begin_src clojure
      (filter (fn [x] (even? x)) [1 2 3 4])
      (filter #(even? %) [1 2 3 4])
      (filter even? [1 2 3 4])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    (2 4)
    #+end_src
     
    If you have a sharp eye, you may have noticed that ~map~ and ~filter~ returned
    lists even though we gave them vectors. Herein lies a powerful difference
    with the Clojure functions --- they are lazy.
     
    What this means is that these functions do not actually execute on each
    element of a sequence until that value is needed.

    For example, the ~take~ function will take the first n elements from a
    sequence. The ~range~ function will produce a list of numbers from 0 to n. 
    If we map over a collection, but only take the first 3, then those three
    elements are the only ones whose values are calculated.

    #+begin_src clojure 
      (take 3 (map #(* % 2) (range 1000000000)))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    (2 4 6)
    #+end_src
     
    Don't believe me? Let's check:
    #+begin_src clojure 
      (take 3 (map #(or (println %) (* % 2)) (range 1000000000)))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    (0 2 4)
    #+end_src
     
    It turns out that for most cases it is actually more efficient to
    calculate them in chunks of 32 elements. So it is not a silver bullet for
    avoiding needless computation, but it does help and it does let us do some
    really cool things. Like the fact that ~range~, when given no argument,
    produces an infinite sequence of numbers. You read that right. Laziness
    allows us to produce infinite sequences and only consume the part we need.

    ~cycle~ takes a sequence and returns an infinitely repeating sequence.
    #+begin_src clojure
      (take 10 (cycle [1 2 3]))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    (1 2 3 1 2 3 1 2 3 1)
    #+end_src
     
    ~iterate~ applies a function ~f~ to ~x~, then ~f~ to that result, and so on,
    infinitely.
    #+begin_src clojure
      (take 10 (iterate #(* % 2) 1))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    (1 2 4 8 16 32 64 128 256 512)
    #+end_src
     
    If we don't want our sequence functions to be lazy, we use versions that
    return vectors, which are not lazy sequences.
    #+begin_src clojure
      (mapv #(* % 2) [1 2 3])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    [2 4 6]
    #+end_src

    #+begin_src clojure
      (filterv even? [1 2 3 4])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    [2 4]
    #+end_src
     
*** Threading Macros
    Threading Macros are my favorite part of Clojure. Commonly, we perform
    sequence functions one after another in a pattern similar to ~map~, then
    ~filter~, then ~reduce~.

    In JavaScript, we do this via method chaining:
    #+begin_src js
      [1, 2, 3, 4]
          .map(x => x * 3)
          .filter(x => x % 2 === 0)
          .reduce((acc, x) => acc + x);
    #+end_src

    #+RESULTS:
    #+begin_src js
    18
    #+end_src
     
    This looks nice and is easy to read. In Lisps, we would traditionally nest
    these function calls.
    #+begin_src clojure
      (reduce + (filter even? (map #(* % 3) [1 2 3 4])))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    18
    #+end_src
     
    This isn't too bad, but you can see how this gets out of hand. That is why
    Clojure introduced the threading macros. They allow a convenient format for
    us to repeatedly apply transformations to our data.

    There is the thread-last macro, ~->>~, that takes a value and applies it as
    the last argument to the first expression, applies the result of that
    expression as the last argument to the next, and so on. It is easier to
    demonstrate:
    #+begin_src clojure
      (->> [1 2 3 4]
           (map #(* % 2)) ;; [3 6 9 12]
           (filter even?) ;; [6 12]
           (reduce +))    ;; 18
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    18
    #+end_src
     
    If you are not sure what is happening, let me illustrate with commas
    indicating where the value is applied. (Remember, commas are whitespace, we
    can put them anywhere).
    #+begin_src clojure
      (->> [1 2 3 4]
           (map #(* % 2) ,,,) ;; [3 6 9 12]
           (filter even? ,,,) ;; [6 12]
           (reduce + ,,,))    ;; 18
    #+end_src
     
    We map over ~[1 2 3 4]~, we ~filter~ over that result, and then ~reduce~ it. 

    The advantage over method chaining is clear as soon as you hit a JavaScript
    function that is not a method. 
     
    Thread-last is traditionally used on operations that involve transforming
    sequences. You will notice those functions take the collection last.

    You may have guessed there is also thread-first macro, ~->~. It is often used
    when transforming singular data types and also when modifying maps. It
    applies the data, and intermittent values, as the first argument to each
    expression.
     
    #+begin_src clojure
      (-> {:a 1 :b 2}
          (assoc ,,, :c 3)
          (dissoc ,,, :a))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    {:b 2, :c 3}
    #+end_src
     
    #+begin_src clojure
      (-> "     test string     "
          (clojure.string/trim ,,,)
          (clojure.string/upper-case ,,,)
          (clojure.string/reverse ,,,))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    "GNIRTS TSET"
    #+end_src

*** Loops
    We haven't talked about for or while loops yet. In most Lisps, we avoid
    these by instead using recursion. Lisps tend to have a feature called
    tail-call optimization that allows us to recur without allocating memory
    for each function call added to the stack. Because Clojure is built on top
    of Java it does not have this feature, and likely never will.

    Instead, it has a ~loop~ macro that enables us to perform a sort of
    recursion. It takes a vector of variables and expressions, and binds the
    variables to the values of those expressions, just like ~let~.
     
    Then, in its body, it either evaluates to a value, or calls ~recur~. ~recur~
    executes the loop body again, but binds the variables to the arguments.
    #+begin_src clojure 
      (loop [variable1 expression1
             variable2 expresssion2
             ...]
        (body))

      (loop [variable1 expression1
             variable2 expresssion2
             ...]
        ;; commonly
        (if some-test
          result
          (recur (transform variable1) (transform variable2))))
    #+end_src
     
    Let's implement summing a list using traditional recursion.
    #+begin_src clojure
      (defn sum-recursively [acc nums]
        (if (empty? nums)
          acc
          (sum-recursively (+ acc (first nums)) (rest nums))))

      (defn sum [coll]
        (sum-recursively 0 coll))

      (sum [1 2 3 4 5])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    15
    #+end_src
     
    In most other Lisps, this would be fine, but if we try it on a large
    collection we will get a stack overflow.
    #+begin_src clojure
      (sum (range 10000000))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    class java.lang.StackOverflowErrorclass java.lang.StackOverflowErrorExecution error (StackOverflowError) at user/eval5761$sum-recursively (REPL:5).
    #+end_src
     
    However, with some minor modifications we can safely use ~loop~.
    #+begin_src clojure
      (defn sum [coll]
        (loop [acc 0
               nums coll]
          (if (empty? nums)
            acc
            (recur (+ acc (first nums)) (rest nums)))))

      (sum [1 2 3 4 5])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    15
    #+end_src

    #+begin_src clojure
      (sum (range 10000000))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    49999995000000
    #+end_src
     
*** Example Problems
    To give some context to what we have talked about, and some additional
    content, here are some coding challenges to attempt and/or read to get a
    feel for Clojure.
**** Longest String in an Array
     Find the longest string in a given array. 
     #+begin_details
     #+begin_summary
     JavaScript
     #+end_summary
     #+begin_src js
       const strings = ["short", "really really long!", "medium"]
       strings.reduce((acc, x) => (x.length > acc.length ? x : acc))
     #+end_src

     #+RESULTS:
     #+begin_src js
     "really really long!"
     #+end_src

     #+end_details
     #+begin_details
     #+begin_summary
     Clojure
     #+end_summary
     #+begin_src clojure
       (def strings ["short" "really really long!" "medium"])
       (reduce #(if (> (count %2) (count %1)) %2 %1) strings)
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     "really really long!"
     #+end_src

     Advanced Solution: Clojure has [[https://clojuredocs.org/clojure.core/max-key][max-key]], which applies a function to its
     other arguments and returns the value that gives the maximum result.
     #+begin_src clojure
       (def strings ["short" "really really long!" "medium"])
       (apply max-key count strings)
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     "really really long!"
     #+end_src
      
     We must use [[https://clojuredocs.org/clojure.core/apply][apply]] because ~max-key~ expects elements given as arguments and
     not a collection. The ~apply~ macro is similar to using the JS spread
     operator, ~...~, to the final collection in the argument list.
     #+end_details
**** Reverse a string
     #+begin_details
     #+begin_summary
     JavaScript
     #+end_summary
     #+begin_src js
       function reverseString(str) {
         return str.split("").reduce(function (a, b) {return b + a});
       }
       reverseString("Hello, World!")
     #+end_src

     #+RESULTS:
     #+begin_src js
     "!dlroW ,olleH"
     #+end_src

     #+end_details
     #+begin_details
     #+begin_summary
     Clojure
     #+end_summary
     #+begin_src clojure
       (clojure.string/join (reverse "Hello, World!"))
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     "!dlroW ,olleH"
     #+end_src

     #+end_details
**** Even Occurrences
     Find the first item that occurs an even number of times in an array.
     Test Array: [1, 7, 2, 4, 5, 6, 8, 9, 6, 4].
     #+begin_details
     #+begin_summary
     JavaScript
     #+end_summary
     #+begin_src js
       const arr = [1, 7, 2, 4, 5, 6, 8, 9, 6, 4];
       function evenOccurrence(arr) {
         const even = arr.reduce((a, x) => (Object.assign(a, {[x]: !(a[x] === undefined || a[x])})), {});
         return arr.find(x => even[x]) || null;
       }
       evenOccurrence(arr);
     #+end_src

     #+RESULTS:
     #+begin_src js
     4
     #+end_src
     #+end_details
     #+begin_details
     #+begin_summary
     Clojure
     #+end_summary
     #+begin_src clojure
       (def arr [1, 7, 2, 4, 5, 6, 8, 9, 6, 4]);
       (defn even-occurrence [coll]
         (let [freqs (frequencies coll)]
           (some #(when (even? (get freqs %)) %) coll)))
       (even-occurrence arr)
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     4
     #+end_src
     
     Not that the Clojure solution correctly handles the case where we have both
     integer and string elements that have the /same/ value, as both will be
     distinct map keys, unlike in the JS solution where they are coerced to
     strings.

     #+end_details

**** Sum Digits
     Write a function that takes a positive integer and returns the sum of its
     individual digits.
     #+begin_details
     #+begin_summary
     JavaScript
     #+end_summary
     #+begin_src js
       function sumOfDigits(num) {
           let acc = 0;
           do {
               acc += num % 10;
               num = Math.floor(num / 10);
           } while (num > 0);
           return acc;
       }
       sumOfDigits(490682);
     #+end_src

     #+RESULTS:
     #+begin_src js
     29
     #+end_src
     #+end_details
     #+begin_details
     #+begin_summary
     Clojure
     #+end_summary
     #+begin_src clojure
       (defn sum-digits [int]
         (->> int
              (iterate #(quot % 10))
              (take-while pos?)
              (map #(mod % 10))
              (reduce +)))
       (sum-digits 490682)
     #+end_src

     #+RESULTS:
     #+begin_src clojure
     29
     #+end_src
     
     #+end_details

*** Destructuring and Function Arguments
    At this point you have all the tools you need to start reading and writing
    Clojure. However, there is still a lot about the language we haven't touched
    on.
    
    Clojure and JavaScript share the convenient ability to destructure data. It
    is most commonly seen in function arguments, in ~let~ and in ~loop~
    declarations. 

    Sequences are destructured intuitively by placing a variable in each
    position of the collection:
    #+begin_src clojure
      (let [[a b c] [1 2 3]]
        (println a b c))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1 2 3
    #+end_src
    
    Instead of the spread operator, an ~&~ is used to indicate we would like to
    collect the rest of elements of a sequence:
    #+begin_src clojure
      (let [[x & xs] [1 2 3 4]]
        (println x)
        (println xs))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1
    (2 3 4)
    #+end_src
    
    Note that the vector was destructured into a list.
    
    We can also destructure while preserving a variable referencing the whole
    structure using the ~:as~ keyword.
    #+begin_src clojure
      (let [[x & xs :as coll] [1 2 3 4]]
        (println x)
        (println xs)
        (println coll))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1
    (2 3 4)
    [1 2 3 4]
    #+end_src
    
    Map destructuring is slightly different. We specify a variable name and the
    key whose value we would like to associate it with.
    #+begin_src clojure
      (let [{a :a, b :b, c :c} {:a 1, :b 2}]
        (println a b c))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1 2 nil
    #+end_src
    
    When we try to destructure a value not present in our data, it is assigned
    ~nil~. With maps, we can specify default data with ~:or~.
    #+begin_src clojure
      (let [{a :a, b :b, c :c, :or {c 8, b 12}} {:a 1, :b 2}]
        (println a b c))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1 2 8
    #+end_src
    
    This is still pretty verbose, so there is an alternate syntax where we do
    automatically associate keys with the appropriate variable name.
    #+begin_src clojure
      (let [{:keys [abc def ghi]} {:abc 1, :def 2, :ghi 3}]
        (println abc def ghi))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1 2 3
    #+end_src
    
    But because we can use anything as a key, there is instead ~:strs~ and ~:syms~
    for string and symbol keys respectively.
    #+begin_src clojure
      (let [{:strs [abc def ghi]} {"abc" 1, "def" 2, "ghi" 3}]
        (println abc def ghi))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1 2 3
    #+end_src

    #+begin_src clojure
      (let [{:syms [abc def ghi]} {'abc 1, 'def 2, 'ghi 3}]
        (println abc def ghi))
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1 2 3
    #+end_src
    
    We can use all of these in function arguments as well.
    #+begin_src clojure
      (defn boxed-inc [[x]] [(+ x 1)])
      (boxed-inc [2])
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    [3]
    #+end_src
    
    There is a special case of destructuring used for when we want to give
    functions keyword arguments.
    #+begin_src clojure
      (defn sample-fn [a b c & {:keys [foo bar baz]
                                :or {foo true, bar false}}]
        (println a b c foo bar baz))

      (sample-fn 1 2 3 :bar "bar")
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1 2 3 true "bar" nil
    #+end_src
    
    Keyword arguments are inherently optional and will be assigned ~nil~ if a
    default value is not given.
    
*** Atoms and Transients
    While all of our standard data structures and variables are immutable, there
    are two common cases where we want and can use mutation.

    The first is the ~atom~. Atoms hold one of our existing data structures. We
    can dereference it with the ~deref~ function or the ~@~ operator to get the
    value it is holding. ~swap!~ updates the value by applying a function, and
    ~reset!~ sets it to the given value.

    #+begin_src clojure
            (let [counter (atom 1)]
              (println (deref counter))
              (swap! counter inc)
              (println @counter)
              (reset! counter 10)
              @counter)
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    1
    2
    10
    #+end_src
    
    All of the functions that perform mutations are explicitly marked with an ~!~
    at the end. All operations on atoms are synchronous. We will see them used
    when we get to the frontend and start building components.
    
    We also have transients. Under the hood, Clojure will create mutable data
    structures to perform efficient operations before returning the immutable
    data structure for our use. Transients let us turn our immutable data
    structures into mutable versions. That is not to say they work like mutable
    arrays in JavaScript.
    
    We call ~transient~ on a data structure to create a mutable copy. It can only
    be modified using special mutable versions of our traditional operators,
    like ~conj!~, ~accoc!~ and so on. Using a normal ~conj~ or other persistent
    function will throw an error, making it impossible to accidentally mix in
    transient structures. We call ~persistent!~ to make our structure immutable.
    
    Transients are distinct from atoms in that they are *not* meant to be modified
    and used independently.
    
    They are correctly used exactly the same as persistent structures. They main
    exceptions being old references to them will be mutated and they are not
    safe to use in multiple threads (something we get for free with persistent data).
    
    #+begin_src clojure
      (def coll (transient [1 2 3 4]))
      (-> coll
          (conj! 5)
          (assoc! 0 0)
          persistent!)
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    [0 2 3 4 5]
    #+end_src
    
    Let's see what happens when we try to continue modifying ~coll~
    #+begin_src clojure
      (assoc! coll 0 1)
    #+end_src

    #+RESULTS:
    #+begin_src clojure
    class java.lang.IllegalAccessErrorclass java.lang.IllegalAccessErrorExecution error (IllegalAccessError) at user/eval7628 (REPL:2).
    Transient used after persistent! call
    #+end_src
    
    That's a helpful error message. ~persistent!~ has an exclamation point, so it
    is telling us that it mutates the data is given. When we apply it we don't
    just return a persistent data structure, we mutate our transient into one
    and cannot continue using old references.

*** Developing using ~lein~
**** Installing Clojure and ~lein~
     Link to instructions
**** Initializing a project
     lein new name
     Project structure
**** project.clj and deps
     Adding dep vectors
     installing
**** namespaces and requiring
*** Other resources
** DONE Wave Function Collapse Explained :wfc:
   CLOSED: [2019-04-22 Mon 04:08]
   :PROPERTIES:
   :export_file_name: wave-function-collapse-explained
   :END:
   #+begin_src elisp :exports none :results silent
    (defun nrepl-send-sync-request (request connection &optional abort-on-input tooling)
      "Send REQUEST to the nREPL server synchronously using CONNECTION.
    Hold till final \"done\" message has arrived and join all response messages
    of the same \"op\" that came along.
    If ABORT-ON-INPUT is non-nil, the function will return nil at the first
    sign of user input, so as not to hang the interface.
    If TOOLING, use the tooling session rather than the standard session."
      (let* ((time0 (current-time))
             (response (cons 'dict nil))
             (nrepl-ongoing-sync-request t)
             status)
        (nrepl-send-request request
                            ;; do not accumulate values by ignoring those that are nil or ""
                            (lambda (resp)
                              (unless (and (nrepl-dict-get resp "value")
                                           (not (eq "" (nrepl-dict-get resp "value"))))
                                (nrepl-dict-put resp "value"
                                                (nrepl-dict-get response "value")))
                              (nrepl--merge (nrepl-dict-put response "value" "")
                                            resp))
                            connection
                            tooling)
        (while (and (not (member "done" status))
                    (not (and abort-on-input
                              (input-pending-p))))
          (setq status (nrepl-dict-get response "status"))
          ;; If we get a need-input message then the repl probably isn't going
          ;; anywhere, and we'll just timeout. So we forward it to the user.
          (if (member "need-input" status)
              (progn (cider-need-input (current-buffer))
                     ;; If the used took a few seconds to respond, we might
                     ;; unnecessarily timeout, so let's reset the timer.
                     (setq time0 (current-time)))
            ;; break out in case we don't receive a response for a while
            (when (and nrepl-sync-request-timeout
                       (> (cadr (time-subtract (current-time) time0))
                          nrepl-sync-request-timeout))
              (error "Sync nREPL request timed out %s" request)))
          ;; Clean up the response, otherwise we might repeatedly ask for input.
          (nrepl-dict-put response "status" (remove "need-input" status))
          (accept-process-output nil 0.01))
        ;; If we couldn't finish, return nil.
        (when (member "done" status)
          (nrepl-dbind-response response (ex err eval-error pp-stacktrace id)
            (when (and ex err)
              (cond (eval-error (funcall nrepl-err-handler))
                    (pp-stacktrace (cider--render-stacktrace-causes
                                    pp-stacktrace (remove "done" status))))) ;; send the error type
            (when id
              (with-current-buffer connection
                (nrepl--mark-id-completed id)))
            response))))
   #+end_src

   #+begin_description
   A clear, visual explanation of the Wave Function Collapse. Generate
   beautifully emergent images from tiny inputs while learning about a unique
   and fun algorithm.
   #+end_description

   If you are not familiar, [[https://github.com/mxgmn/WaveFunctionCollapse][Wave Function Collapse]] (WFC) is an algorithm that
   generates images that are locally similar to input images.

   In general, the algorithm that randomly generates an input that follows rules
   regarding the adjacency of each element.

*** Bird's Eye View
    Here is the basic operation of the algorithm:

    1. Generate a set of tiles from an input image.
    2. Determine which tiles may overlap with each other, generating a set of
       rules for tiles that can be neighbors.
    3. Generate an output image where every pixel can be every tile (a /superposition/).

       a. Choose a pixel with the smallest number of possible tiles, and
       /collapse/ it to a single tile.

       b. Propagate the collapse by checking the pixel's neighbors for tiles
       that are no longer allowed to be there based on our overlapping rules.
       Repeat until there are no more changes.

       c. Goto a
    4. When every pixel is a single value we have finished generating our output
       image. Sometimes, we will reach a contradiction. In this case, we restart
       at 3.
       
    Based on the rules we generated every pixel and its neighbors will be in a
    configuration found in our initial input. This is what we mean when we say
    that our output image is /locally similar/ to our input.

    #+begin_src clojure :results none :exports none
      (use 'hiccup.core)
      (defn pphtml [content]
        (let [in (javax.xml.transform.stream.StreamSource.
                  (java.io.StringReader. (html content)))
              writer (java.io.StringWriter.)
              out (javax.xml.transform.stream.StreamResult. writer)
              transformer (.newTransformer 
                           (javax.xml.transform.TransformerFactory/newInstance))]
          (.setOutputProperty transformer 
                              javax.xml.transform.OutputKeys/INDENT "yes")
          (.setOutputProperty transformer 
                              "{http://xml.apache.org/xslt}indent-amount" "2")
          (.setOutputProperty transformer 
                              javax.xml.transform.OutputKeys/METHOD "xml")
          (.setOutputProperty transformer
                              javax.xml.transform.OutputKeys/OMIT_XML_DECLARATION, "yes")
          (.transform transformer in out)
          (-> out .getWriter .toString print)))
    #+end_src

*** In English, Egon
    Consider the [[https://en.wikipedia.org/wiki/Sudoku][Sudoku]], a puzzle
    based on a grid where each location can be one of a set of numbers that is
    constrained by the values of the other locations. Sound familiar? It is
    essentially the same problem we have created for ourselves, but with
    different constraints.
    
    Let's try to, hypothetically, solve one and follow along with our algorithm.
    We start with a grid where some numbers are already filled in, so we are
    partially through 3. 
    
    #+begin_src clojure :results output html :exports results
      (def sudoku-state
        [[[1 2 5] [6] [1 3]
          8 9 [4 3]
          [1 2 5] 7 [1 4 3]]
         [8 4 [1 3 5]
          2 7 [3 6]
          9 [1 3] [1 3 5 6]]
         [[2 3] 7 9
          1 5 [4 3 6]
          [2 3 8] [3 6] [3 4 6 8]]
         [3 1 9
          4 8 6
          7 2 5]
         [7 5 4
          3 [1 9] 2
          6 8 [1 9]]
         [6 8 2
          5 [1 9] 7
          4 [1 3 9] [1 3]]
         [6 3 7
          [1 9] 4 2
          [1 9] 5 8]
         [1 2 8
          5 [3 9] 7
          4 6 [3 9]]
         [9 4 5
          [3 8] [1 3 6] [1 3 6 8]
          7 2 [1 3]]])

      (defn candidate [num]
        [:div.candidate num])

      (defn cell [val]
        [:div.cell 
         (cond (nil? val) [:div.error 0]
               (number? val) val
               (list? val) [:div.new (cell (first val))]
               :else (map candidate val))])

      (defn block [vals]
        [:div.block (map cell vals)])

      (defn sudoku [state]
        [:div.sudoku (map block state)])

      (pphtml (sudoku sudoku-state))


    #+end_src

    #+RESULTS:
    #+begin_export html
    <div class="sudoku">
      <div class="block">
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">8</div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">8</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">5</div>
          <div class="candidate">6</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">9</div>
        <div class="cell">1</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">4</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">3</div>
        <div class="cell">1</div>
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">8</div>
        <div class="cell">6</div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
      </div>
      <div class="block">
        <div class="cell">7</div>
        <div class="cell">5</div>
        <div class="cell">4</div>
        <div class="cell">3</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">3</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">4</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">5</div>
        <div class="cell">8</div>
      </div>
      <div class="block">
        <div class="cell">1</div>
        <div class="cell">2</div>
        <div class="cell">8</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">6</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
    </div>
    #+end_export

    The first thing we do with a Sudoku is try to find a location where there is
    only one possible number. This is 3a, in the case of a single possibility.
    
    #+begin_src clojure :exports results :results output html
      (def sudoku-state-2
        [[[1 2 5] '(6) [1 3]
          8 9 [4 3]
          [1 2 5] 7 [1 4 3]]
         [8 4 [1 3 5]
          2 7 [3 6]
          9 [1 3] [1 3 5 6]]
         [[2 3] 7 9
          1 5 [4 3 6]
          [2 3 8] [3 6] [3 4 6 8]]
         [3 1 9
          4 8 6
          7 2 5]
         [7 5 4
          3 [1 9] 2
          6 8 [1 9]]
         [6 8 2
          5 [1 9] 7
          4 [1 3 9] [1 3]]
         [6 3 7
          [1 9] 4 2
          [1 9] 5 8]
         [1 2 8
          5 [3 9] 7
          4 6 [3 9]]
         [9 4 5
          [3 8] [1 3 6] [1 3 6 8]
          7 2 [1 3]]])

      (pphtml (sudoku sudoku-state-2))
    #+end_src

    #+RESULTS:
    #+begin_export html
    <div class="sudoku">
      <div class="block">
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">
          <div class="new">
            <div class="cell">6</div>
          </div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">8</div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">8</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">5</div>
          <div class="candidate">6</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">9</div>
        <div class="cell">1</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">4</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">3</div>
        <div class="cell">1</div>
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">8</div>
        <div class="cell">6</div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
      </div>
      <div class="block">
        <div class="cell">7</div>
        <div class="cell">5</div>
        <div class="cell">4</div>
        <div class="cell">3</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">3</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">4</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">5</div>
        <div class="cell">8</div>
      </div>
      <div class="block">
        <div class="cell">1</div>
        <div class="cell">2</div>
        <div class="cell">8</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">6</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
    </div>
    #+end_export

    Once we have filled it in, we check the rest of locations to see how the
    changes effects the numbers allowed in them. This is 3b, propagation.

    We restart. Hopefully, we found a another place with only one possibility.
    If this is a hard Sudoku that may not be the case. Our best bet may be a
    location where there are two possibilities. 

    Without knowing any additional Sudoku strategy, we proceed by selecting one
    at random. This is 3a and what we mean by /collapsing/ to a single value.
    
    #+begin_src clojure :exports results :results output html
      (def sudoku-state-choose
        [[[1 2 5] 6 '(3)
          8 9 [4 3]
          [1 2 5] 7 [1 4 3]]
         [8 4 [1 3 5]
          2 7 [3 6]
          9 [1 3] [1 3 5 6]]
         [[2 3] 7 9
          1 5 [4 3 6]
          [2 3 8] [3 6] [3 4 6 8]]
         [3 1 9
          4 8 6
          7 2 5]
         [7 5 4
          3 [1 9] 2
          6 8 [1 9]]
         [6 8 2
          5 [1 9] 7
          4 [1 3 9] [1 3]]
         [6 3 7
          [1 9] 4 2
          [1 9] 5 8]
         [1 2 8
          5 [3 9] 7
          4 6 [3 9]]
         [9 4 5
          [3 8] [1 3 6] [1 3 6 8]
          7 2 [1 3]]])

      (pphtml (sudoku sudoku-state-choose))
    #+end_src

    #+RESULTS:
    #+begin_export html
    <div class="sudoku">
      <div class="block">
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">6</div>
        <div class="cell">
          <div class="new">
            <div class="cell">3</div>
          </div>
        </div>
        <div class="cell">8</div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">8</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">5</div>
          <div class="candidate">6</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">9</div>
        <div class="cell">1</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">4</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">3</div>
        <div class="cell">1</div>
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">8</div>
        <div class="cell">6</div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
      </div>
      <div class="block">
        <div class="cell">7</div>
        <div class="cell">5</div>
        <div class="cell">4</div>
        <div class="cell">3</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">3</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">4</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">5</div>
        <div class="cell">8</div>
      </div>
      <div class="block">
        <div class="cell">1</div>
        <div class="cell">2</div>
        <div class="cell">8</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">6</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
    </div>
    #+end_export

    In Sudoku, we would continue the puzzle until we finish the puzzle or hit a
    contradiction. 
    
    #+begin_src clojure :exports results :results output html
      (def sudoku-state-error
        [[5 6 3
          8 9 4
          2 7 1]
         [8 4 1
          2 7 6
          9 3 5]
         [2 7 9
          1 5 3
          8 6 4]
         [3 1 9
          4 8 6
          7 2 5]
         [7 5 4
          3 1 2
          6 8 9]
         [6 8 2
          5 9 7
          4 [1 3] 1]
         [6 3 7
          1 4 2
          9 5 8]
         [1 2 8
          5 9 7
          4 6 3]
         [9 4 5
          3 nil [6 8]
          7 2 1]])

      (pphtml (sudoku sudoku-state-error))
    #+end_src

    #+RESULTS:
    #+begin_export html
    <div class="sudoku">
      <div class="block">
        <div class="cell">5</div>
        <div class="cell">6</div>
        <div class="cell">3</div>
        <div class="cell">8</div>
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">2</div>
        <div class="cell">7</div>
        <div class="cell">1</div>
      </div>
      <div class="block">
        <div class="cell">8</div>
        <div class="cell">4</div>
        <div class="cell">1</div>
        <div class="cell">2</div>
        <div class="cell">7</div>
        <div class="cell">6</div>
        <div class="cell">9</div>
        <div class="cell">3</div>
        <div class="cell">5</div>
      </div>
      <div class="block">
        <div class="cell">2</div>
        <div class="cell">7</div>
        <div class="cell">9</div>
        <div class="cell">1</div>
        <div class="cell">5</div>
        <div class="cell">3</div>
        <div class="cell">8</div>
        <div class="cell">6</div>
        <div class="cell">4</div>
      </div>
      <div class="block">
        <div class="cell">3</div>
        <div class="cell">1</div>
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">8</div>
        <div class="cell">6</div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
      </div>
      <div class="block">
        <div class="cell">7</div>
        <div class="cell">5</div>
        <div class="cell">4</div>
        <div class="cell">3</div>
        <div class="cell">1</div>
        <div class="cell">2</div>
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">9</div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
        <div class="cell">9</div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">1</div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">3</div>
        <div class="cell">7</div>
        <div class="cell">1</div>
        <div class="cell">4</div>
        <div class="cell">2</div>
        <div class="cell">9</div>
        <div class="cell">5</div>
        <div class="cell">8</div>
      </div>
      <div class="block">
        <div class="cell">1</div>
        <div class="cell">2</div>
        <div class="cell">8</div>
        <div class="cell">5</div>
        <div class="cell">9</div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">6</div>
        <div class="cell">3</div>
      </div>
      <div class="block">
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">5</div>
        <div class="cell">3</div>
        <div class="cell">
          <div class="error">0</div>
        </div>
        <div class="cell">
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">1</div>
      </div>
    </div>
    #+end_export

    At that point, we would know that we chose the wrong value. We would
    /backtrack/ by erasing anything we had filled in up to that point, and
    change our selection to the other value.
    
    #+begin_src clojure :exports results :results output html
      (def sudoku-state-correct
        [[[2 5] 6 '(1)
          8 9 [4 3]
          [2 5] 7 [4 3]]
         [8 4 [3 5]
          2 7 [3 6]
          9 [1 3] [1 3 5 6]]
         [[2 3] 7 9
          1 5 [4 3 6]
          [2 3 8] [3 6] [3 4 6 8]]
         [3 1 9
          4 8 6
          7 2 5]
         [7 5 4
          3 [1 9] 2
          6 8 [1 9]]
         [6 8 2
          5 [1 9] 7
          4 [1 3 9] [1 3]]
         [6 3 7
          [1 9] 4 2
          [1 9] 5 8]
         [1 2 8
          5 [3 9] 7
          4 6 [3 9]]
         [9 4 5
          [3 8] [1 3 6] [1 3 6 8]
          7 2 [1 3]]])

      (pphtml (sudoku sudoku-state-correct))
    #+end_src

    #+RESULTS:
    #+begin_export html
    <div class="sudoku">
      <div class="block">
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">6</div>
        <div class="cell">
          <div class="new">
            <div class="cell">1</div>
          </div>
        </div>
        <div class="cell">8</div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">8</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">5</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">9</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">5</div>
          <div class="candidate">6</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">9</div>
        <div class="cell">1</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">4</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">2</div>
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">4</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">3</div>
        <div class="cell">1</div>
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">8</div>
        <div class="cell">6</div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
      </div>
      <div class="block">
        <div class="cell">7</div>
        <div class="cell">5</div>
        <div class="cell">4</div>
        <div class="cell">3</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">2</div>
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">8</div>
        <div class="cell">2</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">6</div>
        <div class="cell">3</div>
        <div class="cell">7</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">4</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">5</div>
        <div class="cell">8</div>
      </div>
      <div class="block">
        <div class="cell">1</div>
        <div class="cell">2</div>
        <div class="cell">8</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">4</div>
        <div class="cell">6</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">9</div>
        </div>
      </div>
      <div class="block">
        <div class="cell">9</div>
        <div class="cell">4</div>
        <div class="cell">5</div>
        <div class="cell">
          <div class="candidate">3</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
        </div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
          <div class="candidate">6</div>
          <div class="candidate">8</div>
        </div>
        <div class="cell">7</div>
        <div class="cell">2</div>
        <div class="cell">
          <div class="candidate">1</div>
          <div class="candidate">3</div>
        </div>
      </div>
    </div>
    #+end_export

    In WFC, our constraints are much less severe than Sudoku
    so we don't hit contradictions very often. Instead of backtracking we
    start the whole process over. It is possible to add backtracking to this
    algorithm, but that is out of the scope of this article.
    
    With WFC our numbers are going to be colors (but they could be anything),
    and our constraints result in an image that is consistent with the input
    sample. We will talk about how that works later. The choice of collapsing
    the location with the /lowest entropy/ (read least number of choices) not
    only reduces contradictions, but makes the process beautiful to watch as it
    mimics the human tendency to draw out from what already exists.
    
    That is it. We generate a set of rules, collapse each location to a single
    value and propagate the consequences of the collapse with our rules until
    every location has a single value.
    
*** Wave Function Collapse
    Let's perform the algorithm to get a better feel of how it work. We are
    going start with a an image.

    #+begin_export html
    <div class="scale-sharp">
    #+end_export
    [[file:static/img/maze.png]]
    #+begin_export html
    </div>
    #+end_export

**** Making the Rules

     Let's begin by splitting our image into pixels. This article's scope is only
     to explain how the algorithm works, but you can check the source of this
     article to see the code used to generate all of the following images.
     However, it will be improved and properly explained in the next article out
     our implementation.

     #+begin_src clojure :results output html :exports results
       (def path "static/img/maze.png")

       (defn image->2d [image]
         (let [img (javax.imageio.ImageIO/read (clojure.java.io/file image))]
           (->> img
                (#(.getRGB % 0 0 (.getWidth %) (.getHeight %) (int-array (* (.getWidth %) (.getHeight %))) 0 (.getHeight %)))
                (partition (.getWidth img))
                (mapv vec))))

       (defn int->rgba [int]
         [(bit-shift-right (bit-and int 0x00FF0000) 16)   ;; r
          (bit-shift-right (bit-and int 0x0000FF00) 8)    ;; g
          (bit-and int 0x000000FF)                        ;; b
          (bit-shift-right (bit-and int 0xFF000000) 24)]) ;; a

       (defn rgba->int [[r g b a]]
         (-> (bit-shift-left (bit-and a 0xFF) 24)
             (bit-or (bit-shift-left (bit-and r 0xFF) 16))
             (bit-or (bit-shift-left (bit-and g 0xFF) 8))  
             (bit-or (bit-and b 0xFF))))

       (defn rgba->hex [[r g b a]]
         (format "#%02x%02x%02x%02x" r g b a))

       (def sample (image->2d path))

       (defn pixel [int-rgba]
         [:span.pixel {:style (str "background-color:" (-> int-rgba int->rgba rgba->hex))} " "])

       (defn pixel-tile [n tile]
         [:div.pixel-tile {:style (str "--n: " n)} (map #(map pixel %) tile)])

       (pphtml (pixel-tile 4 sample))
     #+end_src

     #+RESULTS:
     #+begin_export html
     <div class="pixel-tile" style="--n: 4">
       <span class="pixel" style="background-color:#dfba61ff"> </span>
       <span class="pixel" style="background-color:#dfba61ff"> </span>
       <span class="pixel" style="background-color:#dfba61ff"> </span>
       <span class="pixel" style="background-color:#dfba61ff"> </span>
       <span class="pixel" style="background-color:#dfba61ff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
       <span class="pixel" style="background-color:#dfba61ff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
       <span class="pixel" style="background-color:#697e6dff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
       <span class="pixel" style="background-color:#dfba61ff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
       <span class="pixel" style="background-color:#272822ff"> </span>
     </div>
     #+end_export

     With our sample image, the next step is divide it into tiles, in this case
     2 pixel by 2 pixel regions. 

     In this case, we have chosen to have our tiling wrap. When our tile
     selector hits an edge, it will get the pixels on the opposite side. This is
     one of the ways we increase the number of tiles in an input image to
     improve our output. Other methods include rotating and reflecting each tile
     to get even more.
     
     #+begin_src clojure :results output html :exports results
       (defn subtile [tile x y width height & {:keys [wrap?]}]
         (let [tile   (if wrap? (cycle (map cycle tile)) tile)
               width  (if (and (not wrap?) (neg? x)) (+ width x)  width)
               height (if (and (not wrap?) (neg? y)) (+ height y) height)
               x      (if wrap? (Math/abs x) (max x 0))
               y      (if wrap? (Math/abs y) (max y 0))]
          (->> tile
               (drop y)
               (take height)
               (map #(drop x %))
               (mapv #(vec (take width %))))))

       (defn transpose [tile]
         (apply mapv vector tile))

       (defn reflect-y [tile]
         (mapv (comp vec rseq) tile))

       (defn reflect-x [tile]
         (vec (rseq tile)))

       (defn permutations [tile]
         ((juxt identity reflect-x reflect-y (comp reflect-x reflect-y) transpose) tile))


       (defn sample->tiles [sample tile-size & {:keys [permutations?]}]
         (let [tiles (for [y (range (count sample))
                           x (range (count (first sample)))]
                       (subtile sample x y tile-size tile-size :wrap? true))]
           (if-not permutations?
             tiles
             (reduce concat (map permutations tiles)))))

       (def tiles (sample->tiles sample 2))

       (defn pixel-tiles [tile-size tiles]
         [:div.pixel-tiles (map #(pixel-tile tile-size %) tiles)])

       (pphtml (pixel-tiles 2 tiles))
     #+end_src

     #+RESULTS:
     #+begin_export html
     <div class="pixel-tiles">
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#697e6dff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#697e6dff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#697e6dff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#697e6dff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
       </div>
       <div class="pixel-tile" style="--n: 2">
         <span class="pixel" style="background-color:#272822ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
         <span class="pixel" style="background-color:#dfba61ff"> </span>
       </div>
     </div>
     #+end_export
     
     Quite a few of the tiles above are repeated and WFC makes use of that
     information. Tiles that more frequently appear in the sample more frequently
     appear in the output. When /collapsing/ a pixel to a single tile out of all
     the possible tiles, the probability for each one to be selected is weighted
     by its frequency in the sample image. 
     
     Above, it is obvious that the neighboring tiles are able to overlap. We
     want to know, for every tile, which tiles it can overlap with in all
     directions. Let's take a look at the first tile.
     
     #+begin_src clojure :results output html :exports results
       (defn offsets [tile-size]
         (let [limit (dec tile-size)]
           (for [x (range (- limit) (inc limit))
                 y (range (- limit) (inc limit))
                 :when (not (and (zero? x) (zero? y)))]
             [x y])))

       (defn overlap? [tile1 tile2 offset]
         (let [[x y] offset
               tile-size (count tile1)]
           (= (subtile tile1 x y tile-size tile-size)
              (subtile tile2 (- x) (- y) tile-size tile-size))))

       (defn pairings [coll]
         (reduce concat (for [[indexa a] (map-indexed vector coll)]
                          (for [b (drop indexa coll)]
                            [a b]))))

       ;; :tiles -> :overlaps
       (defn calculate-overlaps [tiles]
         (let [num-tiles (count tiles)
               offs (offsets (count (first tiles)))]
           (reduce (fn [overlaps [index1 index2]]
                     (reduce (fn [overlaps offset]
                               (-> overlaps ;; add to both tiles' overlaps map
                                   (update-in [index1 offset] (fnil conj #{}) index2)
                                   (update-in [index2 (mapv - offset)] (fnil conj #{}) index1)))
                             overlaps
                             (filter #(overlap? (get tiles index1) (get tiles index2) %) offs)))
                   ;; vector to hold maps of overlaps at each offset
                   (vec (repeat num-tiles {})) 
                   ;; unique tile index pairings
                   (pairings (range num-tiles))))) 

       (defn preprocess [sample-path tile-size & {:keys [permutations?]}]
         (->> (sample->tiles (image->2d sample-path) tile-size :permutations? true)
              frequencies
              transpose
              (map vector [:tiles :freqs])
              (into {})))


       (def tiles-freqs (preprocess path 2))

       (def tile-index (some (fn [[i t]]
                               (when (= t [[-2114975 -2114975] [-2114975 -14211038]]) i))
                             (map-indexed vector (:tiles tiles-freqs))))

       (def tile-overlaps
         (-> (preprocess path 2)
             :tiles
             calculate-overlaps
             (nth tile-index)
             (assoc [0 0] #{tile-index})))

       (def expanded-overlaps (sort-by (comp vec reverse first) 
                                       (reduce-kv (fn [m k v]
                              (assoc m k (mapv #(nth (:tiles tiles-freqs) %) v)))
                            {} tile-overlaps)))

       (pphtml [:div.overlaps (map #(vector :div (str (first %)) (pixel-tiles 2 (second %))) expanded-overlaps)])
     #+end_src

     #+RESULTS:
     #+begin_export html
     <div class="overlaps">
       <div>[-1 -1]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
       <div>[0 -1]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
       <div>[1 -1]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
       <div>[-1 0]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
       <div>[0 0]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
         </div>
       </div>
       <div>[1 0]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
       <div>[-1 1]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
       <div>[0 1]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
       <div>[1 1]<div class="pixel-tiles">
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#697e6dff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#697e6dff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#697e6dff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
           <div class="pixel-tile" style="--n: 2">
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
             <span class="pixel" style="background-color:#272822ff"> </span>
             <span class="pixel" style="background-color:#dfba61ff"> </span>
           </div>
         </div>
       </div>
     </div>
     #+end_export
     
     At no offset, ~[0 0]~, we see the tile in question. At ~[-1 -1]~ are all of
     the tiles that overlap when shifted left and up once. In other words, for
     each tile in ~[-1 -1]~, their bottom right pixel matches the top left pixel
     of the tile at ~[0 0]~.
     

***** An Optimization
     
      We could move on from here, but it turns out some of this information is
      redundant and noticing this provided a key performance improvement to the
      algorithm. We don't need to consider any offsets besides left, right, up
      and down (at least for the 2d case).
     
      Take a look at ~[1 1]~. Note that for each tile it either overlaps
      vertically with a tile in ~[1 0]~, or horizontally with a tile in ~[0 1]~.
      This should make sense, as the bottom right pixel in ~[0 0]~ would need to
      match for all three.
      
      Therefore, we don't need to consider the diagonal offsets directly as the
      are already constrained by their adjacent, cardinal offsets. When it comes
      time to collapse and propagate changes, we only need to consider 4
      neighbors instead of 8. 

      In other words, any changes we make that would effect tiles allowed in a
      diagonal offset doesn't need to be handled directly. It will be implicitly
      by updating the allowed tiles in the cardinal directions and propagating
      its changes left, right, up or down.
      
      If this is confusing, don't worry. We are a little ahead of ourselves, and
      it will make more sense when we discuss propagation.

***** Local Similarity

      All of the tiles in the above overlaps initially seem to fit, but you may
      have noticed something odd in ~[1 1]~. We noted that for each tile, it
      overlaps with either a tile in ~[1 0]~ vertically, or ~[0 1]~
      horizontally. In fact, all of the tiles match with both, except for one,
      the tile that is all black except for a green pixel on the bottom
      left.
      
      Let's select that tile and see what happens.
     
      #+begin_export html
      <div class="pixel-tile" style="--n: 3; max-width: 150px;">
        <span class="pixel" style="background-color:#dfba61ff"> </span>
        <span class="pixel" style="background-color:#dfba61ff"> </span>
        <span class="pixel" style="background-color:transparent"> </span>
        <span class="pixel" style="background-color:#dfba61ff"> </span>
        <span class="pixel" style="background-color:#272822ff"> </span>
        <span class="pixel" style="background-color:#272822ff"> </span>
        <span class="pixel" style="background-color:transparent"> </span>
        <span class="pixel" style="background-color:#697e6dff"> </span>
        <span class="pixel" style="background-color:#272822ff"> </span>
      </div>
      #+end_export
     
      While it fits now, try to choose a tile from the ~[0 1]~ offset.

      #+begin_export html
      <div class="pixel-tile" style="--n: 3; max-width: 150px;">
        <span class="pixel" style="background-color:#dfba61ff"> </span>
        <span class="pixel" style="background-color:#dfba61ff"> </span>
        <span class="pixel" style="background-color:transparent"> </span>
        <span class="pixel" style="background-color:#dfba61ff"> </span>
        <span class="pixel" style="background-color:#272822ff"> </span>
        <span class="pixel" style="background-color:#272822ff"> </span>
        <span class="pixel" style="background-color:#dfba61ff"> </span>
        <span class="pixel" style="background-color:red"> </span>
        <span class="pixel" style="background-color:#272822ff"> </span>
      </div>
      #+end_export
     
      We get a conflict. The tiles in ~[0 1]~ necessitate that their bottom right
      pixel must be either yellow or black, which is impossible having already
      selected the ~[1 1]~ tile with the green pixel.
      
      This is how the algorithm enforces /local similarity/. What that means is
      that this arrangement of pixels is never found in the sample image,
      therefore we do not allow it to appear in the output image.
     
      #+begin_export html
      <div class="scale-sharp">
      #+end_export
      [[file:static/img/maze.png]]
      #+begin_export html
      </div>
      #+end_export
      
      We see that there is no place where a yellow pixel borders a green one,
      either cardinally or diagonally, hence the contradiction.

**** Initializing the Output
      
      This post is in progress. Check back later for the rest of the algorithm.
